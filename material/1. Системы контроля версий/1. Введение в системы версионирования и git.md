## Введение в системы версионирования и git

### Определение и виды систем контроля версий

Система контроля версий (VCS) - это система, регистрирующая изменения в одном или нескольких файлах с тем, чтобы в дальнейшем была возможность вернуться к определённым старым версиям этих файлов.

Виды VCS:
- Локальные - файлы и их версии хранятся локально на компьютере пользователя. Примеры: RCS (Revision Control System).
- Централизованные - репозиторий хранится на центральном сервере, пользователи копируют к себе нужные файлы, вносят в них изменения и отправляют изменённые файлы в хранилище. Пример: SVN (Subversion).
- Распределённые - репозиторий с удалённого сервера целиком копируется на компьютер пользователя. Примеры: Git, Mercurial, Bazaar, Darcs.

### Git

Чтобы начать работу с git-репозиторем, необходимо его получить. Имеется два способа, рассмотрим наиболее типичный - клонирование с удалённого сервера:

```bash
git clone https://gitlab.com/login/project.git
```

В этот момент в той директории, из которой была вызвана команда появится папка с названием `project`, в которой, помимо имеющихся в репозитории файлов, будет скрытая папка `.git`, хранящая в себе историю изменений файлов. Все команды git при запуске будут искать в текущей директории или в родительских (до корня файловой системы) папку с именем `.git`, чтобы понять, относительно какого репозитория выполняться. Если такой не находится, то будет записываться соответствующая ошибка.

**Коммит (commit)** - версия репозитория. Представляет собой набор содержимого всех файлов в репозитории в определённый момент времени. Имеет идентификатор - хеш SHA содержимого репозитория. Таким образом, каждая версия репозитория представляется коммитом и у каждой версии есть своё уникальное имя (хеш).

**Ветка (branch)** - именованная последовательность коммитов. У репозитория всегда есть хотя бы одна ветка. По-умолчанию она называется master (можно потом изменить). Все другие ветки "ответвляются" от главной ветки. Это означает, что разработка может вестись параллельно - один разработчик добавляет коммиты в одну ветку, а другой - в другую.

Команда `git status` показывает краткую информацию о состоянии репозитория:
```bash
% git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        .gitignore
        README.md

nothing added to commit but untracked files present (use "git add" to track)
```

Здесь записано, что на данный момент репозиторий находится на ветке master и есть два новых файла: .gitignore и README.md. Также написано, что стоит использовать команду `git add`, чтобы добавить изменения.

Команда `git add <file>` добавляет файлы в так называемый индекс. Коммит в этот момент не создаётся, но в момент создания коммита в него будут добавлены только те изменения, что есть в индексе[^1].

Добавим в индекс файл .gitignore:
```bash
% git add .gitignore 
% git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   .gitignore

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        README.md

```

Теперь вывод команды `git status` показывает, что в индексе есть .gitignore, а README.md всё ещё не в индексе. Тут же указано, как убрать файл из индекса (если теперь уже не хочется его коммитить): `git rm --cached <file>`. Важно: в `git add` и `git rm` можно передавать не только отдельные файлы, но и директории - в этом случае в индекс попадут все изменённые в данной директории файлы.

Теперь можно создавать коммит - очередную версию репозитория:
```bash
git commit
```
В этот момент откроется редактор по-умолчанию в системе. Для *nix системы это либо vim, либо nano. В этом редакторе будет предложено ввести сообщение коммита. Это может быть произвольный текст, описывающий, какие именно изменения были привнесены этим коммитом.

Удобно использовать флаг `-m`, чтобы не открывать редактор почём зря:
```bash
git commit -m "fixed bug"
```

Чтобы послать изменения на удалённый сервер достаточно ввести команду
```bash
git push
```

Все коммиты, созданные локально, отправятся на сервер.

Кратко перечислим другие команды git:
* `git checkout <branch|commit_hash|tag>` - изменение состояния репозитория: переход к другой ветке, конкретному коммиту или тэгу коммита.
* `git checkout -b <branch_name>` - создание новой ветки от текущей и переход в неё.
* `git pull` - выкачивание актуального состояния репозитория с удалённого сервера. Дополнительно производит merge удалённой ветки в текущую.
* `git log` - вывод истории изменений репозитория. 

[^1]: В mercurial, например, этот механизм устроен иначе.